package net.devromik.textFileIndexer.impl.karkkainenSanders;

import java.nio.file.Path;
import net.devromik.textFileIndexer.impl.AbstractIndex;
import net.devromik.textFileIndexer.OccurrencePosIterator;

/**
 * Приведенная ниже схема работы является наброском.
 * С большой долей вероятности она содежит неточности и ошибки.
 * Общая идея, тем не менее, должна быть понятна.
 *
 * Высокоуровневая схема работы Алгоритма Карккайнена-Сандерса выглядит следующим образом:
 *     1. Строим суффиксный массив для тех суффиксов, которые начинаются в некратных трем позициях исходной строки.
 *        Чтобы выполнить это построение, рекурсивно сводим его к построению суффиксного массива для строки длиной в две трети от исходной.
 *     2. Строим суффиксный массив для суффиксов, которые начинаются в кратных трем позициях исходной строки, используя для этого результаты первого шага.
 *     3. Выполняем слияние суффиксных массивов, полученных на шагах 1 и 2.
 *
 * На каждом из этих трех шагов мы получаем суффиксный массив, соответствующий некоторому подможеству суффиксов исходной строки.
 * Такой суффиксный массив мы будем называть суффиксным подмассивом.
 * Суффиксный подмассив самодостаточен в том смысле, что он позволяет найти соответствующее ему подмножество позиций вхождений заданной строки в исходную строку.
 * При этом будут найдены те и только те вхождения, которые начинаются в тех же позициях, что и суффиксы, входящие в суффиксный подмассив.
 *
 * Будем считать, что вместе с суффиксным подмассивом нам доступны позиции суффиксов исходной строки, входящих в этот суффиксный подмассив.
 * Естественно, эту информацию придется поддерживать по ходу индексации. Технические детали опустим.
 *
 * Теперь мы готовы описать два основных процесса при работе с индексом:
 * построение индекса и поиск с его помощью всех вхождений заданной строки в исходную строку.
 *
 * ------------------------------
 *
 * Построение индекса:
 *
 * Работая по приведенной выше высокоуровневой схеме алгоритма Карккайнена-Сандерса,
 * формируем структуру SuffixSubarray (суффиксный подмассив):
 *     a. int id: идентификатор суффиксного подмассива.
 *     b. SuffixSubarray firstFormativeSuffixSubarray: первый образующий суффиксный подмассив.
 *        Получается в результате рекурсивного вызова на шаге 1.
 *     c. SuffixSubarray secondFormativeSuffixSubarray: второй образующий суффиксный подмассив.
 *        secondFormativeSuffixSubarray.suffixArray (см. пункт d) - суффиксный массив тех суффиксов исходной строки (на текущем уровне рекурсии),
 *        которые начинаются в позициях, кратных трем.
 *        Вместе с LCP.
 *        secondFormativeSuffixSubarray.firstFormativeSuffixSubarray == secondFormativeSuffixSubarray.secondFormativeSuffixSubarray == null.
 *     d. suffixArray: суффиксный массив, соответствующий результату, полученному на шаге 3.
 *        Представляет собой объединение суффиксных массивов,
 *        соответствующих firstFormativeSuffixSubarray и secondFormativeSuffixSubarray.
 *        Вместе с LCP.
 *        Храним в постоянной памяти.
 *        В оперативной памяти храним только локационную информацию, позволяющую найти суффиксный массив в постоянной памяти.
 *     e. Множество операций, инкапсулирующих доступ к постоянной памяти
 *        (например, в это множество войдет операция, позволяющая находить все вхождения, учитываемые suffixArray).
 *
 * Таким образом, в ходе построения индекса, мы постоянно получаем новые суффиксные подмассивы.
 * Как только мы получаем новый суффиксный подмассив, регистрируем его в SuffixSubarrayProvider.
 * SuffixSubarrayProvider предоставляет клиентам множество всех актуальных SuffixSubarray.
 * SuffixSubarray считается актуальным до тех и только до тех пор, пока не будет сформирован "объемлющий" SuffixSubarray
 * (для которого данный SuffixSubarray является либо firstFormativeSuffixSubarray, либо secondFormativeSuffixSubarray)
 * и последний читатель не закончит с ним работать.
 * При этом firstFormativeSuffixSubarray становится доступен для клиентов сразу после завершения его формирования.
 * Уже затем начинается формирование secondFormativeSuffixSubarray.
 *
 * ------------------------------
 *
 * Поиск всех вхождений заданной строки в исходную строку:
 *
 * Для этого нам потребуется определить реализацию OccurrencePosIterator.
 * Реализация OccurrencePosIterator:
 *     - имеет в своем распоряжении SuffixSubarrayProvider.
 *     - итерация осуществляется следующим образом. Для каждого актуального суффиксного подмассива actualSuffixSubarray:
 *           1. Если actualSuffixSubarray уже был обработан, переходим к обработке следующего актуального суффиксного подмассива.
 *           2. Если actualSuffixSubarray.firstFormativeSuffixSubarray уже был обработан,
 *              переходим к обработке actualSuffixSubarray.secondFormativeSuffixSubarray (шаг 3 не выполняем).
 *              actualSuffixSubarray при этом помечаем как обработанный.
 *           3. Выполняем поиск вхождений в суффиксном массиве actualSuffixSubarray.suffixArray с помощью стандартного алгоритма.
 *              Эти значения возвращаем в getNext().
 *              actualSuffixSubarray, actualSuffixSubarray.firstFormativeSuffixSubarray и actualSuffixSubarray.secondFormativeSuffixSubarray
 *              помечаем как обработанные.
 * Приведенная реализация OccurrencePosIterator легко может быть сделана ленивой.
 *
 * @author Shulnyaev Roman
 */
public final class ExternalMemoryKarkkainenSandersIndex extends AbstractIndex {

    ExternalMemoryKarkkainenSandersIndex(Path sourceFilePath) {
        super(sourceFilePath);
    }

    @Override
    public OccurrencePosIterator getOccurrencePosIterator(String soughtForCharSeq) {
        throw new UnsupportedOperationException("Not supported");
    }
}